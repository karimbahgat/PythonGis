"""
Sub-Module of tk2: Tkinter Placer
Provides additional placement features for Tkinter's .place manager.
Note: Most of the functionality in this module requires that the widget uses a
place manager (not pack or grid)
"""

#PYTHON VERSION CHECKING
import sys
PYTHON3 = int(sys.version[0]) == 3
if PYTHON3:
    xrange = range


    
#CLASSES
class Partition:
    """
    An instance representing a rectangular area of space, and is
    generated by the PartitionSpace function (not the user).
    Provides the user with easy access to that space's anchorpoints.
    The anchorpoints are given in the same format as what was used
    to create the partition in the first place, ie either absolute
    or relative xy coordinates.

    The anchorpoints are accessed as attributes and include:

    - .center: the xy center point of the partition
    - .width: the width of the partition
    - .height: the height of the partition
    - .nw: the northwest xy corner
    - .n: the north xy point
    - .ne: the northeast xy corner
    - .e: the east xy point
    - .se: the southeast xt corner
    - .s: the south xy point
    - .sw: the southwest xy corner
    - .w: the west xy point
    """
    def __init__(self, center, partitionwidth, partitionheight, direction):
        if direction == "vertical":
            center = (center[1],center[0])
            partitionwidth,partitionheight = partitionheight,partitionwidth
        self.center = center
        self.width = partitionwidth
        self.height = partitionheight
        midx,midy = center
        halfx = partitionwidth/2.0
        halfy = partitionheight/2.0
        self.nw = (midx-halfx, midy-halfy)
        self.n = (midx, midy-halfy)
        self.ne = (midx+halfx, midy-halfy)
        self.e = (midx+halfx, midy)
        self.se = (midx+halfx, midy+halfy)
        self.s = (midx, midy+halfy)
        self.sw = (midx-halfx, midy+halfy)
        self.w = (midx-halfx, midy)
    def __repr__(self):
        visualstring = "partition:\n"
        visualstring += "%s \t %s \t %s \n" % tuple([[str(nr)[:5] for nr in pair] for pair in (self.nw,self.n,self.ne)])
        visualstring += "%s \t %s \t %s \n" % tuple([[str(nr)[:5] for nr in pair] for pair in (self.w,self.center,self.e)])
        visualstring += "%s \t %s \t %s" % tuple([[str(nr)[:5] for nr in pair] for pair in (self.sw,self.s,self.se)])
        return visualstring
    def SubPartition(self, partitions, padx, pady, direction="horizontal"):
        """
        Creates additional subpartitions from this partition.
        Note: Can be buggy so only use if you really need to avoid nested widgets, eg if you need to structure your widgets over a large background image bc a background widget to nest them in would cover up parts of the image

        - partitions: how many subpartitions to create, integer
        - padx: how much padding to keep between each partition on the sides, integer for pixels or float for relative position.
        - pady: how much padding to keep between each partition on the top and bottom, integer for pixels or float for relative position.
        - direction: a string indicating in which direction to partition the space, "horizontal" (default) or "vertical".
        
        """
        xtox = (self.w[0], self.e[0])
        ytoy = (self.n[1], self.s[1])
        return PartitionSpace(xtox, ytoy, partitions, padx, pady, direction)

def PartitionSpace(xtox, ytoy, partitions, padx, pady, direction="horizontal"):
    """
    Partitions an abstract coordinate space into subdivisions,
    returning multiple Partition instances which provide easy
    access to the various anchorpoints of each partition.
    Useful for placing widgets at regular spaced out intervals
    when using the Tkinter .place geometry manager, which
    usually requires the user to set positions manually.
    The original coordinate space can be defined as pixels or
    relative positions.

    - xtox: a two-item list or tuple containing the leftmost and rightmost x position, in that order. For each use integer for pixels or float for relative position.
    - ytoy: a two-item list or tuple containing the topmost and bottommost y position, in that order. For each use integer for pixels or float for relative position.
    - partitions: how many subpartitions to create, integer
    - padx: how much padding to keep between each partition on the sides, integer for pixels or float for relative position.
    - pady: how much padding to keep between each partition on the top and bottom, integer for pixels or float for relative position.
    - direction: a string indicating in which direction to partition the space, "horizontal" (default) or "vertical".

    Example:

    ```
    import Tkinter as tk
    import tk2
    
    win = tk.Tk()
    frame = tk.Frame(win, width=500, height=500)
    frame.pack()
    
    for partition in tk2.PartitionSpace(xtox=(200,500), ytoy=(200,500), partitions=5, padx=10, pady=10):    
        #first get partition info
        partx,party = partition.center
        partwidth,partheight = partition.width,partition.height
        
        #then place widget using partition info
        widget = tk.Label(frame, bg="blue")
        widget.place(x=partx, y=party, width=round(partwidth), height=round(partheight), anchor="center")
    ```
    
    """
    
    startx, endx = xtox
    starty, endy = ytoy
    if direction == "vertical":
        startx,starty = starty,startx
        endx,endy = endy,endx
        padx,pady = pady,padx
    #prep
    allwidth = endx-startx
    allheight = endy-starty
    widthafterpad = allwidth-padx*(partitions+1)
    heightafterpad = allheight-pady*2
    partitionwidth = widthafterpad/float(partitions)
    partitionheight = heightafterpad
    #calc
    outpartitions = []
    tempx = startx+padx+partitionwidth/2.0
    tempy = starty+pady+partitionheight/2.0
    for _ in xrange(partitions):
        center = (tempx, tempy)
        outpartitions.append( Partition(center, partitionwidth, partitionheight, direction) )
        tempx += partitionwidth/2.0+padx+partitionwidth/2.0
    return outpartitions


#TESTING
if __name__ == "__main__":
    if PYTHON3:
        import tkinter as tk
    else:
        import Tkinter as tk
    import random
    win = tk.Tk()
    testdims = (1100,500)
    testparts = 3

##    #pixel positions test
##    testpadx,testpady = (90,20)
##    frame = tk.Frame(win, bg="red", width=testdims[0], height=testdims[1])
##    frame.pack()
##    hm = tk.Label(frame, bg="yellow")
##    hm.place(x=200,y=200)
##    for partition in PartitionSpace((200,testdims[0]),(0,testdims[1]),testparts,testpadx,testpady):
##        but = tk.Label(frame, bg="blue")
##        x,y = partition.center
##        print (partition.w, x, partition.e)
##        but.place(x=x, y=y, width=round(partition.width), height=round(partition.height), anchor="center")

    #rel test
    testpadx,testpady = (0.01,0.01)
    frame = tk.Frame(win, bg="red", width=testdims[0], height=testdims[1])
    frame.pack(fill="both")
    hm = tk.Label(frame, bg="yellow")
    hm.place(relx=0.3,rely=0.5, anchor="ne")
    #horiz partitions
    partitions = PartitionSpace((0.3,1),(0.7,1),testparts,testpadx,testpady)
    subpart = partitions[0]
    for partition in partitions:
        but = tk.Label(frame, bg="blue")
        x,y = partition.center
        but.place(relx=x, rely=y, relwidth=partition.width, relheight=partition.height, anchor="center")
        #split each down the middle
        subpartitions = partition.SubPartition(2, 0.01, 0.02)
        #left side
        subpart = subpartitions[0]
        but = tk.Label(frame, bg="green")
        x,y = subpart.center
        but.place(relx=x, rely=y, relwidth=subpart.width, relheight=subpart.height, anchor="center")
        #then try downwards partition
        subsubpartitions = subpart.SubPartition(5, 0.006, 0.006, direction="vertical")
        for subpart in subsubpartitions:
            but = tk.Label(frame, bg="red")
            x,y = subpart.center
            but.place(relx=x, rely=y, relwidth=subpart.width, relheight=subpart.height, anchor="center")
        #right side
        subpart = subpartitions[1]
        but = tk.Label(frame, bg="green")
        x,y = subpart.center
        but.place(relx=x, rely=y, relwidth=subpart.width, relheight=subpart.height, anchor="center")
        #then try downwards partition
        subsubpartitions = subpart.SubPartition(5, 0.006, 0.006, direction="vertical")
        for subpart in subsubpartitions:
            but = tk.Label(frame, bg="white", text="text")
            x,y = subpart.center
            but.place(relx=x, rely=y, relwidth=subpart.width, relheight=subpart.height, anchor="center")
    #finalize window
    coordsdisplay = tk.Label(win, text="mousepos")
    coordsdisplay.place(relx=0.01, rely=0.01)
    def displaymousecoords(event):
        coordsdisplay["text"] = "%s,%s (%s,%s)" %(event.x,event.y, event.x/float(win.winfo_width()),event.y/float(win.winfo_height()))
    win.bind("<Motion>", displaymousecoords)
    win.mainloop()
        
